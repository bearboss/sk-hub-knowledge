title: 数据结构

date: 2021-08-15 15:20:36

tags: 数据结构

categories: 数据结构

copyright: true

sticky: 0

---

<span id="delete">

![](/images/banner/100.jpg)

</span>

<!--more-->

# 左右旋转
   ![](/images/code/rl.jpg) 
# AVL树的性质

  ```
  1.左右节点度不能大于1,平衡二叉树
  2.需要左旋右旋来维持平衡
  3.存在平衡因子概念
  ```
  
# 红黑树的五个性质

```
    1.性质
    
        1.根节点是黑色
        2.节点是黑色或者红色
        3.叶子节点全是黑色(null节点)
        4.红节点的子节点都是黑
            -- 红节点的父亲节点都是黑
            -- 从根到叶子节点不能连续两个红色节点    
        5.根节点到任意节点的包含相同数目的黑节点
        
    2.红黑树类比于四阶B数
        1.删除非叶子节点,需要找到前驱或者后继节点来代替,删除的都是叶子节点
        2.不满足红黑树性质,删除需要下溢,然后左右旋转来保持平衡
        3.添加节点需要上溢,然后左右旋转来保持平衡
    3.红黑树为什么效率高long(n)
        左右节点路径最长为2倍 即黑节点立马跟上红节点,弱平衡
```

# MAP 与 Set
```
TreeMap 运用红黑树作为数据存储,Key就是天然的不重复,可比较
所以TreeSet 类比于 TreeMap<KEY,NULL>
```
# 计算hash槽

    计算hash公式: hash_code(key)&(tableSize-1);
 
1） 公式

```
    & 位运算 双1为 1 其余全为0 
    | 或运算 一个为1，其值为1。
    ^ 异或运算 值相同为0 值不同为1
    
    将x的第i个位置，置1   x|(1<<i)
    将x的第i个位置，置0   x&(~(1<<i));
    将x的第i个位置, 取反  x^(1<<i);
    检测x的第i个位置, 1还是0 (x&(1<<i)) > 0
    将x最低的1的位置置为0 x&(x-1);  x = 1001000  x-1= 1000111
    y是x的“子状态" ，（x|y） == x
    枚举所有x的子状态 for(y=x;y>0;y=(y-1)&x);
```
    
2） 为什么hashMap要进行&(tableSize-1);

```
    tableSize 强制数组长度为2^n 如:4
    2^n : 转成二进制类似:100
    2^n-1 转成二进制:011
    hash_code(key) 无论计算出来多少的32位INT长度与011进行&运算 都是2位 
    1010 1010 1010 1010 1010 1010 1010 1010
    0000 0000 0000 0000 0000 0000 0000 0011
    = 10 
    所以计算槽位结果为数组2,永远比2^n-1小 
    就是比tableSize数组长度小
```

3）如何生成Key的hash值

```
    key的常见种类可能有:
    
    整数 浮点数 字符串 自定义对象
    不同种类的key哈希值生成方式不一样 但目标一致
        尽量让每个key的哈希值唯一的
        尽量让KEy的所有信息参与运算
    
    JAVA hashMap 的key必须实现hashCode.equals方法 也允许为null
```

4） hash_code计算32位hash值 其实就是int

```
    (int) (value ^ (value>>>32))
    
    int 的hash值就是自己
    float 将存储的二进制格式转成整数 Float.floatToIntBits() 查看整数信息
    double 转成64位整数 Double.doubleToLongBits() ,高低32位进行异或运算
    long 高低32位进行异或运算
    
    value>>>32:无符号右移32位
    value :                 1111 1111 1111 1111 1111 1111 1111 0001 0001 0001 0001 0001 0001 0001
    value>>>32 :            0000 0000 0000 0000 0000 0000 0000 1111 1111 1111 1111 1111 1111 1111
    value ^ (value>>>32):   1111 1111 1111 1111 1111 1111 1111 1110 1110 1110 1110 1110 1110 1110
    (int)( value ^ (value>>>32)):: 1110 1110 1110 1110 1110 1110 1110
    为什么是异或运算:
    如果是与运算: 全是低位数据,高位数据未参与运算
    如果是或运算: 全是高位数据,低位数据未参与运算
    异或运算:则最大程度高低为都参与运算
    最后强制转换成32位 结果丢弃高32位: 1110 1110 1110 1110 1110 1110 1110

```

5）字符串计算hash

```
    5894 : 5*10^3+8*10^2+9*10^1+4*10^0
    套用规则:
    jack : j*n^3+a*n^2+c*n^1+k*n^0
        重复计算优化:[(j*n+a)*n+c]*n+k
    在JDK中 乘数n为31 ,为什么是31呢?
        31是奇素数,JVM会将31*i优化成(i<<5)-i
        System.out.println(31*i);
        System.out.println((i<<5)-i);
     
    计算字符串hash公式:
    public static void main(String[] args){
        String string = "jack";
        int len = string.length();
        int hashcode = 0;
        for (int i = 0; i < len; i++) {
            char c = string.charAt(i);
            //hashcode = hashcode*31 + c ;
            hashcode = (hashcode<<5)-hashcode + c;
        }
        System.out.println(hashcode);
    }
```
6）自定义对象计算hash

```
    还是按照字符串数字来处理,重写hashCode
     public static int hashCode(Object a[]) {
        if (a == null)
            return 0;

        int result = 1;

        for (Object element : a)
            result = 31 * result + (element == null ? 0 : element.hashCode());

        return result;
    }
```
7）为什么要重新hashcode和equals
![](/images/code/cao.jpg) 
```
    首先:Hash表是数组:hash值是计算数组索引,数组中存储的是实际key-value元素
    hash是比较索引槽在那里
    equals是hash冲突的时候比较槽里存的数据key是不是相同
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ActivitiAdvanceSettingEntity)) return false;
        ActivitiAdvanceSettingEntity that = (ActivitiAdvanceSettingEntity) o;
        return Objects.equals(getRemarkRequired(), that.getRemarkRequired()) &&
                Objects.equals(getMyAuditAutoPass(), that.getMyAuditAutoPass()) &&
                Objects.equals(getRemarkTip(), that.getRemarkTip()) &&
                Objects.equals(getAutoRepeat(), that.getAutoRepeat()) &&
                Objects.equals(getNotVisibleForSponsor(), that.getNotVisibleForSponsor());
    }
```