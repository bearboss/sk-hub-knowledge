title: 算法总结

date: 2021-09-11 15:20:36

tags: 算法总结

categories: 算法总结

copyright: true

sticky: 0

---

<span id="delete">

![](/images/banner/103.jpg)

</span>

<!--more-->
![](/images/java/补码.png)

# ListNode

```
    public class ListNode {
       public int val;
       public ListNode next;
       ListNode() {}
       ListNode(int val) { this.val = val; }
       ListNode(int val, ListNode next) { this.val = val; this.next = next; }
    
       @Override
       public String toString() {
          return val + " -> " + next ;
       }
    }
```

# TEST
```
    public static void main(String[] args) {
        ListNode listNode = new ListNode(1);
        listNode.next = new ListNode(2);
        listNode.next.next = new ListNode(3);
        listNode.next.next.next = new ListNode(4);
        listNode.next.next.next.next = new ListNode(5);
        listNode.next.next.next.next.next = new ListNode(6);
        listNode.next.next.next.next.next.next = new ListNode(7);
        Test test = new Test();
        ListNode node = test.reverseNode(listNode);
        System.out.println(node);
    }
```

# 移除链表元素

```
    public ListNode removeNode(ListNode head,int val) { 
        ListNode newHead = new ListNode(0);
        ListNode newTail = newHead;
        while (head != null) {
            if (head.val != val) {
                //修改newHead指针的指向
                newTail.next = head;
                //重置尾结点
                newTail = newTail.next;
            }
            head = head.next;
        }
        newTail.next = null;
        return newHead.next;
    }
```

# 翻转链表

```
    public ListNode reverseNode(ListNode head) { 
        ListNode newHead = null;
        while(head != null){
            //建一个临时节点存储
            ListNode temp = head.next;
            
            //当前元素1指向null;以此类推 2 -> 1 -> null 
            head.next = newHead;
            newHead =  head;
            
            //继续遍历下一个元素
            head = temp;
        }
        return newHead;
    }
```

# 快慢指针求中心节点

* 快指针走两步 慢指针走一步,一旦快指针下一个节点或者下下个节点为null,慢指针就是中心节点
 
```
    public ListNode middleNode(ListNode head) { 
       ListNode slow = head;
       ListNode fast = head;       
       while(fast.next != null && fast.next.next != null){
            slow = slow.next; 
            fast = fast.next.next;
       }
       return slow;
    }
```

# 利用栈求解左/右边第一个比它大的数

![](/images/sort/stack.png)

```
    /**
     * 主函数
     */  
    public static void main(String[] args) {
        int[] nums = {3, 2, 1, 6, 0, 5};
        parentIndex(nums);
    }
    /**
     * 利用栈求解左/右边第一个比它大的数
     */
    public int[] parentIndex(int[] nums) {
        //1.扫描一遍所有的元素
        //2.保持栈底到栈顶是单调递减的
        //3.遍历到的数大于栈顶数: 栈顶数右边的第一个大的数是遍历到的数,并且不停的弹出来
        //4.遍历到的数小于栈顶数: 遍历元素左边第一个大的数是栈顶数
        //5.将该数入栈
        Stack<Integer> stack = new Stack<>();
        int[] lis = new int[nums.length];
        int[] ris = new int[nums.length];
        for (int i = 0; i < nums.length; i++) {
            lis[i] = -1;
            ris[i] = -1;
            while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
                ris[stack.pop()] = i;
            }
            if (!stack.isEmpty()) {
                lis[i] = stack.peek();
            }
            stack.push(i);
        }
        //从左右去选择一个最小的就是父节点
        int[] pis = new int[nums.length];
        for (int i = 0; i < pis.length; i++) {
            if (lis[i] == -1 && ris[i] == -1) {
                pis[i] = -1;
                continue;
            }
            if (lis[i] == -1) {
                pis[i] = ris[i];
            } else if (ris[i] == -1) {
                pis[i] = lis[i];
            } else if (nums[lis[i]] < nums[ris[i]]) {
                pis[i] = lis[i];
            } else {
                pis[i] = ris[i];
            }
        }
        System.out.println(Arrays.toString(pis));
        return pis;
    }
```

# 求每日温度

![](/images/sort/温度.png)

```
    /**
     * 主函数
     */
    public static void main(String[] args) {
        int[] tmp = {73, 74, 75, 71, 69, 72, 76, 73};
        Solution8 solution8 = new Solution8();
        solution8.dailyTemperatures(tmp);
    }
    
    /**
     * 利用栈,求解右边第一个比它大的数
     */
    public int[] dailyTemperatures2(int[] temperatures) {
        int[] ris = new int[temperatures.length];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < temperatures.length; i++) {
            while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {
                Integer peek = stack.pop();
                ris[peek] = i - peek;
            }
            stack.push(i);
        }
        System.out.println(Arrays.toString(ris));
        return ris;
    }
    
    /**
     * 倒推法-类比动态规划
     */
    public int[] dailyTemperatures(int[] T) {
        int[] values = new int[T.length];
        for (int i = T.length - 2; i >= 0; i--) {
            int j = i + 1;

            while (true) {
                if (T[i] < T[j]) {
                    values[i] = j - i;
                    break;
                } else if (values[j] == 0) {
                    values[i] = 0;
                    break;
                } else if (T[i] == T[j]) {
                    values[i] = values[j] + j - i;
                    break;
                } else {
                    j = j + values[j];
                }
            }
        }
        System.out.println(Arrays.toString(values));
        return values;
    }
    
    /**
     * 倒推法优化
     */
    public int[] dailyTemperatures3(int[] T) {
        int[] values = new int[T.length];
        for (int i = T.length - 2; i >= 0; i--) {
            int j = i + 1;

            while (true) {
                if (T[i] < T[j]) {
                    values[i] = j - i;
                    break;
                } else if (values[j] == 0) {
                    values[i] = 0;
                    break;
                }
                j = j + values[j];
            }
        }
        System.out.println(Arrays.toString(values));
        return values;
    }
    
```
# 二叉树遍历

```
# 递归版本
    #前中后
    public void preOrder(TreeNode root) {
         if(root == null) return null;
         #System.out.println(root.val); # 前序 根左右
         preOrder(root.left);
         #System.out.println(root.val); # 中序 左根右
         preOrder(root.right);   
         #System.out.println(root.val); # 后序 左右根
    }
    #层序
    public void levelOrder(TreeNode root) {
        List<Integer> list = new ArrayList();
        levelOrder(root, 1,list);
        #System.out.println(Arrays.toString(list.toArray()));
    }
    public void levelOrder(TreeNode root, int i, List list) {
        if (root == null) return;
        int length = list.size();
        if (length <= i) {
            for (int j = 0; j < i - length ; j++) {
                list.add(length + j, null);
            }
        }
        list.set(i, root.val);
        //定位元素在数组中的问题  左边是2*i  右边是 2*i+1
        levelOrder(root.left, 2 * i, list);
        levelOrder(root.right, 2 * i + 1, list);
    }
    
#  迭代版本
    #1. 前中后 , 使用对象去绑定  
        public static class Opt {
            private String op;
            private TreeNode node;
    
            Opt(String op, TreeNode node) {
                this.op = op;
                this.node = node;
            }
        }
        public void preOrder(TreeNode root) {
            if (root == null) return;
            Stack<Opt> stack = new Stack<>();
            stack.add(new Opt("op", root));
            while (!stack.isEmpty()) {
                Opt opt = stack.pop();
                if ("op".equals(opt.op)) {
                    TreeNode node = opt.node;
                    //后序stack.add(new Opt("pt", node));
                    if (node.right != null) {
                        stack.add(new Opt("op", node.right));
                    }  
                    //中序stack.add(new Opt("pt", node));
                    if (node.left != null) {
                        stack.add(new Opt("op", node.left));
                    }
                    //前序stack.add(new Opt("pt", node));
                } else {
                    System.out.println(opt.node.val);
                }
            }
        }       
    #2. 正常使用while方式
        #前序
        public void preOrder(TreeNode root) {
            if(root == null) return;
            Stack<TreeNode> stack = new Stack<>();
            stack.add(root);
            while (!stack.isEmpty()) {
                root = stack.pop();
                if(root == null) continue;
                System.out.println(root.val);
                stack.add(root.right);
                stack.add(root.left);
            }
        }
        #中序
        public static void preOrder(TreeNode root) {
            if (root == null) return;
            Stack<TreeNode> stack = new Stack<>();
            while (!stack.isEmpty() || root != null) {
                if (root != null) {
                    stack.add(root);
                    root = root.left;
                } else {
                    TreeNode pop = stack.pop();
                    System.out.print(pop.val);
                    root = pop.right;
                }
            }
        }
        
        # 后序
        public static void preOrder(TreeNode root) {
            if (root == null) return;
            Stack<TreeNode> stack = new Stack<>();
            TreeNode prev = null;
            while (!stack.isEmpty() || root != null) {
                while (root != null) {
                    stack.add(root);
                    root = root.left;
                }
                root = stack.pop();
                if(root.right == null || root.right == prev){
                    System.out.print(root.val);
                    prev = root;
                    root = null;
                }else{
                    stack.push(root);
                    root = root.right;
                }
            }
        }
        #层序
        public List<List<Integer>> levelOrder(TreeNode root) {
             List<List<Integer>> list = new ArrayList<>();
            if(root == null) return list;
            Queue<TreeNode> queue = new LinkedList() ;
            queue.add(root);
            while(!queue.isEmpty()){
                List<Integer> sub = new ArrayList<>();
                //这里很重要,要把size放出来
                int size = queue.size();
                for (int i = 0; i < size; i++) {
                     TreeNode poll = queue.poll();
                     sub.add(poll.val);
    
                     if(poll.left != null){
                        queue.offer(poll.left);
                     }
                     if(poll.right != null) {
                        queue.offer(poll.right);
                     }
                }
                list.add(sub);
            }
            return list;
    
        }
# morris 遍历 (找前驱结点然后指向自己)  前驱结点是垂直方向左边(不论层级)离自己最近的节点
    # 前序
    public static void morrisOrder(TreeNode cur) {
        if (cur == null) return;
        TreeNode mostRight = null;
        while (cur != null) {
            //前驱结点
            mostRight = cur.left;
            if (mostRight != null) {
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {
                    //前驱结点指向当前节点
                    mostRight.right = cur;
                    //打印根
                    System.out.print(cur.val);
                    cur = cur.left;
                    continue;
                } else {
                    // 删除前驱结点指向当前节点
                    mostRight.right = null;
                }
            } else {
                //打印左边
                System.out.print(cur.val);
            }
            cur = cur.right;
        }
    }
    
    # 中序
    public static void morrisOrder(TreeNode cur) {
        if (cur == null) return;
        TreeNode mostRight = null;
        while (cur != null) {
            //前驱结点
            mostRight = cur.left;
            if (mostRight != null) {
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {
                    //前驱结点指向当前节点
                    mostRight.right = cur; 
                    cur = cur.left;
                    continue;
                } else {
                    // 删除前驱结点指向当前节点
                    mostRight.right = null;
                }
            }
            //开启打印
            System.out.print(cur.val);
            cur = cur.right;
        }
    }
    
    # 后序
    public static void morrisOrder(TreeNode cur) {
        TreeNode root = cur;
        if (cur == null) return;
        TreeNode mostRight;
        while (cur != null) {
            //前驱结点
            mostRight = cur.left;
            if (mostRight != null) {
                while (mostRight.right != null && mostRight.right != cur) {
                    mostRight = mostRight.right;
                }
                if (mostRight.right == null) {
                    //前驱结点指向当前节点
                    mostRight.right = cur;
                    cur = cur.left;
                    continue;
                } else {
                    // 删除前驱结点指向当前节点
                    mostRight.right = null;
                    //打印左边的数据
                    println(cur.left);
                }
            }
            cur = cur.right;
        }
        //打印根节点的链
        println(root);
    }

    private static void println(TreeNode left) {
        //翻转链表
        TreeNode tail = reverse(left);

        while (tail != null) {
            System.out.print(tail.val);
            tail = tail.right;
        }

        reverse(left);
    }

    private static TreeNode reverse(TreeNode head) {
        TreeNode next = null;
        while (head != null) {
            TreeNode temp =  head.right;
            head.right = next;
            next = head;
            head = temp;
        }
        return next;
    }
```
# 省份数量
```
#深度优先
    public int findCircleNum(int[][] citysConnected) {
        int citys = citysConnected.length;

        boolean[] visited = new boolean[citys];

        int provinces = 0;

        for (int i = 0; i < citys; i++) {
            if (visited[i]) continue;
            dfs(i, visited, citysConnected, citys);
            provinces++;
        }

        return provinces;
    }

    private void dfs(int i, boolean[] visited, int[][] citysConnected, int citys) {
        int[] ints = citysConnected[i];
        for (int j = 0; j < citys; j++) {
            if (ints[j] == 1 && !visited[j]) {
                visited[j] = true;
                dfs(j, visited, citysConnected, citys);
            }
        }
    }
# 广度优先
    public int findCircleNum(int[][] citysConnected) {
        int citys = citysConnected.length;
        boolean[] visited = new boolean[citys];
        int provinces = 0;
        Queue<Integer> queue = new LinkedList();
        for (int i = 0; i < citys; i++) {
            if (visited[i]) continue;
            queue.offer(i);
            while(!queue.isEmpty()){
                Integer k = queue.poll();
                visited[k] = true;
                for (int j = 0; j < citys; j++) {
                    int[] ints = citysConnected[i];
                    if (ints[j] == 1 && !visited[j] ) {
                        queue.offer(j);
                    }
                }
            }
            provinces++;
        }
        return provinces;
    }
# 并查集
        int mergeFind(int[][] citys) {
        int length = citys.length;
        int[] head = new int[length];
        int[] level = new int[length];
        for (int i = 0; i < length; i++) {
            head[i] = i;
            level[i] = 1;
        }
        for (int i = 0; i < length; i++) {
            for (int j = i + 1; j < length; j++) {
                merge(i, j, head, level);
            }
        }
        int count = 0;
        for (int i = 0; i < head.length; i++) {
            if(head[i] == i)count++;
        }
        return count;
    }
     static void merge(int x, int y, int[] head, int[] level) {
        int i = find(x, head);
        int j = find(y, head);

        if (i == j) return;

        if (level[i] <= level[j]) {
            head[i] = j;
        } else {
            head[j] = i;
        }

        if (level[i] == level[j]) {
            level[i]++;
            level[j]++;
        }
    }
    static int find(int x, int[] head) {
        if (head[x] == x) return x;
        head[x] = find(head[x], head);
        return head[x];
    } 
```
# 字符查找  indexOf
```
    1.暴力查找,双层循环
    2.使用hash,整段hash.每个字母定义成 1,2,3数字.然后求和,比较总和.移动就减最前面的再加上后面的,计算总和
    3.bm算法,好后缀和坏字符,两种中式使用,增加跳过的概率.直接定位到新的字符
    4.kmp
```

# 最大公约数算法
```
    public static int gcd(int a, int b) {
        return  b > 0 ? gcd(b, a % b) : a;
    }
```

# 最小公倍数算法
```
    public static int lcm(int a, int b) {
        return  a/gcd(a,b)*b;
    }
```
# 最少操作次数是前若干个偶数或者奇数的和
```
——取决于n的奇偶性。本质是“等差数列的”中间项 leetcode 1551
public int minOperations(int n) {
        // 除以4.分析规律
        return (n * n - (n & 1)) >> 2;
    }

```