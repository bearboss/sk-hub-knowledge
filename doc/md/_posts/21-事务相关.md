title: 事务相关

date: 2021-05-29 15:20:36

tags: 事务

categories: Java

copyright: true

sticky: 0

---

<span id="delete">

![](/images/banner/21.jpg)

</span>

<!--more-->

## dubbo 服务

> （zookeeper） 注册中心
	
	消费者              发布者

	1.发布者发布服务会通知消费者
	2.消费者连接发布者的地址去得到数据

## 分布式事务数据一致性

* (1)把事务ABC统一转成D的本地事务 - 把本来规划拆分好的业务，又耦合到了一起，业务职责不清晰，不利于维护。
* (2)eBay 模式 - 是将需要分布式处理的任务通过消息日志的方式来异步执行

## 数据库事务机制

### 查看全局和本地的隔离级别

    select @@GLOBAL.tx_isolation, @@tx_isolation;

### 数据库隔离级别

> （set SESSION TRANSACTION ISOLATION LEVEL XX ） 
    
* 可重复读（REPEATABLE READ ）  
- - 事务隔离性可以重复读即使另外一边已经修改了。
* 脏读	（ READ UNCOMMITTED）	
- - 在这边事务中可以读到另一边事务未提交的数据
* READ COMMITTED 			
- - 读已经提交了的，这边读可能数据会不同
* SERIALIZABLE 			
- - 线性读，事务依次读

### 表锁/行锁

* 等待上一个事务执行完成之后再查询结果，事务未完成一直锁住该条记录
* 使用for update如果不加条件会锁住整个表 加上条件只会锁住一条记录
- - select * from xx where id =2 for update

## Spring事务管理

### Spring事务抽象接口

* PlaformTransactionManager(事务管理器接口)	
- TransactionDefinition(事务的定义 事务的属性 - 传播属性等等)
- TransactionStatus(事务的运行状态)
		
### TransactionDefinition的隔离机制

- TransactionDefinition.ISOLATION_DEFAULT 			
- - 与数据库隔离级别一致
- TransactionDefinition.ISOLATION_READ_COMMITTED 	
- - 事务可以读另一个提交事务的数据
- TransactionDefinition.ISOLATION_READ_UNCOMMITTED 	
- - 事务可以读另一个事务未提交的数据（脏读）
- TransactionDefinition.ISOLATION_REPEATABLE_READ 	
- - 事务读不到别的事务修改的数据（重复读）
- TransactionDefinition.ISOLATION_SERIALIZABLE 		
- - 线性读 等待上一个完成才执行下一个
		
### TransactionDefinition	传播机制

>两个方法都有事务，相互调用 之间如何传播

>A事务  B事务 相互调用

>都是B设置传播机制	

- PROPAGATION_REQUIRED(default) 
- - B要求A有事务，没有就创建事务
- PROPAGATION_SUPPORTS 		
- - B有事务，A必须有，B没有 A乜没有
- PROPAGATION_MANDATORY 		
- -  A必须有事务
- PROPAGATION_REQUIRES_NEW 	
- - B先暂停之前的事务，重新启事务
- PROPAGATION_NOT_SUPPORTED 	
- - B的这个方法不在事务执行
- PROPAGATION_NEVER 		
- - B不会在事务执行
- PROPAGATION_NESTEDED 		
- - JDBC3.0才能使用 嵌套事务 

## JPA事务管理 

### 代码方式

    @Autowire 
    PlaformTransactionManager txManager
    
    DefaultTransactionDefinition def = new DefaultTransactionDefinition ();
    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    TransactionStatus.status = txManager.getTransaction(def);
    try{
        ...业务代码
        txManager.commit(status);
    }catch(){
        txManager.rollback(status);
    }

### @Transactional 声明式事务


## JMS session 事务管理 （activeMQ）
	
> 发生错误默认重试7次
	
> listener监听 事务是整个方法
	
> 直接发送 事务是单行。convertAndSend 内部起作用

### JMS transactionManager 管理事务

#### 创建JmsConfig.java --事务的配置项
    @EnableJms
    @Configuration
    public class JmsConfig {
        @Bean
        PlatformTransactionManager transactionManager(ConnectionFactory factory){
            return new JmsTransactionManager(factory);
        }
        @Bean
        JmsTemplate jmsTemplate(ConnectionFactory factory){
            JmsTemplate jmsTemplate =  new JmsTemplate();
            jmsTemplate.setConnectionFactory(factory);
            return  jmsTemplate;
        }
        @Bean
        JmsListenerContainerFactory<?> msgFactory(ConnectionFactory cf, PlatformTransactionManager transactionManager,DefaultJmsListenerContainerFactoryConfigurer configurer){
            DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
            configurer.configure(factory,cf);
            factory.setReceiveTimeout(10000L);
            factory.setTransactionManager(transactionManager);
            return factory;
        }
    }

##### 声明式事务（注解）

    @Transactional
    @JmsListener(destination = "customer:msg1:new",containerFactory = "msgFactory")

##### 代码方式 - 使用事务 同样使用 msgFactory作为事务配置
		
    @Autowired
    PlatformTransactionManager transactionManager;
    TransactionDefinition tx = new DefaultTransactionDefinition();
    TransactionStatus status = transactionManager.getTransaction(tx);
    try{
        ...业务代码 
        transactionManager.commit(status);
    }catch (Exception e){
        e.printStackTrace();
        transactionManager.rollback(status);
    }

## Spring 本地事务和外部事物 与 JTA
	
> 一个java服务访问多个数据源，保证数据一致性

### XA规范的JAVA实现-JTA

* 3个接口
* * TransactionManager
* * XAResource 
* * XID

* 弊端
* * 两阶段提交
* * 事务时间太长，锁数据时间太长
* * 低性能，高吞吐量

* 单个数据库 
```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jta-atomikos</artifactId>
</dependency>
```
* 自动创建JTA的事务

* 两个事务在入口@Transactional

## 分布式系统

### 基本原则

#### CAP理论

* C 一致性
* A 可用性
* P 分区容错性

#### BASE理论

* 基本可用（Basically Available）
* 软状态（Soft State）
* 最终一致性（Eventually Consistent）

#### 一致性

* 强一致性			
* 弱一致性
* * 一个服务一个服务去调用
* 最终一致性
* * 人工啊，定时任务去扫描

### 几种分布式系统

* 多数据源
* 多服务
* soa
* 微服务

### 分布式系统考虑问题

* 服务分拆
* 数据分拆
* 计算拆分
* 服务状态以及异常处理

### 微服务架构组成

* 服务发现与注册
* 服务网关与负载均衡
* 监控与熔断机制
* 配置、消息等	

### Spring Cloud 微服务架构

* SpringCloud Netflix 
* SpringCloud Config
* SpringCloud BUS

#### SpringCloud Netflix 

* 服务注册中心：Eureka
* 网关：ZUUL
* 声明式Rest调用接口：Feign Client
* 负载均衡：Ribbon
* 监控、熔断组件:Hystrix与Hystrix Dashboard	

#### Spring Cloud Config 配置服务	

* 配置：文件夹，GIT ，SVN，DB
* 配置服务器
* 服务_>配置服务器_>配置

## 分布式事务实现方式		

### XA与最后资源博弈

* JTA 可分成两段提交

### 共享资源

* 两个数据源共享一个底层资源
* ActiveMQ使用DB作为存储
* 使用DB上的connection控制事务提交
* 需要数据源支持

### 最大努力一次提交 MQ方式的实现

* 依次提交事务
* 可能出错
* 通过AOP或者Listener实现事务直接的同步

### 链式事务

* 定义事务链
* 多个事务在一个事务管理器依次次执行
* 将不同的数据源的datasource放进链式source里面执行

### 如何选择
		
* 强一致性事务：JTA（性能最差，只是用于单个服务内）Amokios
* 弱、最终一致性事务：最大努力一次提交、链式事务（设计相应的错误处理机制）
* MQ-DB:最大努力一次提交+重试
* 多个DB：链式事务管理
* 多个数据源：链式事务/或其他事务同步

