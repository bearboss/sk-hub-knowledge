title: 分布式限流

date: 2021-05-25 15:20:37

tags: 分布式限流

categories: 分布式限流

copyright: true

sticky: 0

---

<span id="delete">

![](/images/banner/4.jpg)

</span>

<!--more-->
# 谷歌 guava
```
 <dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>18.0</version>
</dependency>

RateLimiter limiter = RateLimiter.create(2.0);
// 非阻塞限流
@GetMapping("/tryAcquire")
public String tryAcquire(Integer count) {
    if (limiter.tryAcquire(count)) {
        log.info("success, rate is {}", limiter.getRate());
        return "success";
    } else {
        log.info("fail, rate is {}", limiter.getRate());
        return "fail";
    }
}
// 限定时间的非阻塞限流
@GetMapping("/tryAcquireWithTimeout")
public String tryAcquireWithTimeout(Integer count, Integer timeout) {
    if (limiter.tryAcquire(count, timeout, TimeUnit.SECONDS)) {
        log.info("success, rate is {}", limiter.getRate());
        return "success";
    } else {
        log.info("fail, rate is {}", limiter.getRate());
        return "fail";
    }
}

// 同步阻塞限流
@GetMapping("/acquire")
public String acquire(Integer count) {
    limiter.acquire(count);
    log.info("success, rate is {}", limiter.getRate());
    return "success";
}
```
# nginx的限流
```
1.基于IP地址的限制 
  binary_目的是缩写内存占用
  remote_addr表示通过IP地址来限流
  iplimit 是一块内存区域,20M是内存区域的大小(记录访问频率信息)
  rate=1r/s 每秒放行一个请求 ,其他配置: 100/m
  limit_req_zone $binary_remote_addr zone=iplimit:20m rate=10r/s;
2.基于服务器做限流
  limit_req_zone $server_name zone=serverlimit:10m rate=1r/s;
3.基于链接数的配置
  limit_conn_zone $binary_remote_addr zone=perip:20m;
  limit_conn_zone $server_name zone=perserver:20m;
3.应用
  location /doris/ {
      proxy_pass http://127.0.0.1:8989/doris/;
      #基于IP地址的限制 - zone=iplimit 引用变量规则
      #burst=2 设置一个大小为2的缓冲区域 ,当大量请求到来,请求数据超过限流频率时放入缓存区域
      #nodelay 缓冲区满了直接返回503异常
      limit_req zone=iplimit burst=2 nodelay;
      #通常情况下,server级别的限流速率是最大的
      limit_req zone=serverlimit burst=1 nodelay;
      
      limit_conn perserver 100; #每个server最多保持100个链接
      limit_conn perip 1;#每个IP最多保持1个链接
      
      limit_req_status 504; # 错误返回状态码504,不配置默认503
      limit_conn_status 504; # 错误返回状态码504,不配置默认503
  }
4.限制下载文件的速率
   location /down/ {
      limit_rate_after 100m; 超过100m之后限速
      limit_rate 256k;
  } 
```
# redis+lua简单使用
```
eval "return {KEYS[1],ARGV[1]}" 2 K1 K2 V1 V2

script load "return 'hello'"
evalsha 1b936e3fe509bcbc9cd0664897bbe8fd0cac101b 0

script load "return 'hello lua'..KEYS[1]"
evalsha "6e2466b4db65a6b11ee99749d4a489804d7d668e" 1 KEY1 VUA1 

script exists "6e2466b4db65a6b11ee99749d4a489804d7d668e"

script flush
```
# 基于redis+lua客户端限流
```
1.编写lua脚本
  local key = KEYS[1]
  
  redis.log(redis.LOG_DEBUG,'KEY IS',key)
  
  local limit = tonumber(ARGV[1])
  
  local count = tonumber(redis.call('get',key) or  "0")
  
  if count + 1 > limit then
      return false
  else
      redis.call("INCRBY" , key , 1)
      redis.call("expire" , key , 100)
      return true;
  end

2. DefaultRedisScript 加载lua脚本
@Configuration
public class RedisConfiguration {
	@Bean
	public RedisTemplate<String, String> redisTemplate(RedisConnectionFactory factory) {
		return new StringRedisTemplate(factory);
	}
	@Bean
	public DefaultRedisScript loadRedisScript() {
		DefaultRedisScript redisScript = new DefaultRedisScript();
		redisScript.setLocation(new ClassPathResource("ratelimiter.lua"));
		redisScript.setResultType(Boolean.class);
		return redisScript;
	}
}

@Service
public class AccessLimiter {

	@Autowired
	private StringRedisTemplate stringRedisTemplate;

	@Autowired
	private RedisScript<Boolean> rateLimitLua;
	
	public boolean limitAccess(String key, Integer limit) {
		// step1 请求lua脚本
		boolean acquired = stringRedisTemplate.execute(
				rateLimitLua, // lua script的脚本
				Lists.newArrayList(key),// lua script脚本的Key列表
				limit.toString()//lua脚本的value列表
		);
		if (!acquired) {
			throw new RuntimeException("已被限流");
		}
		return acquired;
	}
}
3. 测试
@RestController
public class AccessLimiterController {
	@Autowired
	private AccessLimiter accessLimiter;
	
	@GetMapping("/test")
	public void limitAccess() {
		// step1 请求lua脚本
		boolean acquired = accessLimiter.limitAccess("limitAccess", 2);

		if (!acquired) {
			throw new RuntimeException("已被限流");
		}
	}
}
```
