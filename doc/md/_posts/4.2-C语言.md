title: C语言

date: 2021-05-25 15:20:37

tags: C语言

categories: C语言

copyright: true

sticky: 0

---

<span id="delete">

![](/images/banner/4.jpg)

</span>

<!--more-->

# VS 配置

* alt+G是查看反汇编

![](/images/c++/vs1.png)

![](/images/c++/vs2.png)

![](/images/c++/vs3.png)
# if-switch
```
if else 条件比较多依次比较,比较到最后会执行更多的汇编指令
switch 
    条件比较少,和if/else汇编一样,效率也一样
    条件比较多,编译器优化,固定执行几个汇编指令,再跳转
    事先存好所有的条件地址,并且连续存储,并且以0开始,乱序无影响
    jmp [(no-第一个条件的数值)*4 + 第一个条件函数地址]
    
```
# 基础语法

## 模式 
```
debug模式: 很多调试信息
Release模式: 去除调试信息,生成可执行文件比较高效,精简
```
## 固定头部文件
```
#include <iostream>
using namespace std;
getchar(); 停留获取键盘输入
```
## 输入输出
```
cout 是 输出 用 << 运算符
cin  是 输入 用 >> 运算符
endl是换行
示例:
int main(){
	cout << "please 输入:" << endl;
	int age;
	cin >> age;
	cout << "age is :" << age << endl;
	getchar();
	return 0;
}
```
## 字节数
```
E8 45 EE FF FF       call        display (0171479h[函数内存地址]) 
调用 display 函数在内存中占用5字节
且机器指令函数内存是连续的
```
## 函数重载
* 规则:
* * 函数名相同
* * 参数个数不同,参数类型,参数顺序不同
* 注意:
* * 调用函数时,实参的隐式转换可能产生二义性
* * 函数返回值和重载无关
```
    #隐式转换产生二义性
    int dis(long a){
    }
    int dis(double a){
    }
    dis(10);
```
* 本质
* * 采取了name mangling 或者 name decoration技术
* * 编译器会对符号名(如函数名)进行改编,修饰
* * 可用IDA pro工具查看反汇编-使用release模式-并且禁用编译器优化
```
    # 重新编排 叫dis_int() 或者 dis_1 ,看具体规则
    int dis(int a){
    }
    # 重新编排 叫dis_double()
    int dis(double a){
    }
```
## 函数默认参数
```
int sum(int v1,int v2){
    return v1+v2;
}
(1) v1=5,v2 =6 默认值 5,6
(2) 默认参数只能 右到左,依次从右填充
(3) 函数同时有声明(声明:是表明在main函数前面,实现在main函数后面),实现,默认参数只能放在函数声明中
(4) 默认参数值可以是常量,全局符号(全局变量,函数名)
    函数名:
        void(*p)(int) = test;  // 表示 存在一个函数test ,返回值是空,参数为int 
        p(1);
(5)函数重载和默认参数有可能会产生二义性 - 优先使用默认参数
    void display(int a,int b = 20){}
    void display(int a){}
    display(10);
(6) 本质
    直接将默认值push到函数中-意思就是还是传了两个参数
```

# extern C
* 被extern C修饰的代码会被C语言的方式去编译
```
extern "C" dis(int a){}
extern "C" dis(){}

extern "C" {
    int dis(int a){}
    int dis(double a){}
}
```
* 声明和实现同时存在 ,extern C 必须修饰声明,实现也可以加
```
extern "C" void dis(int a);
extern "C" void dis(int a){}
```
* 使用: 在开发过程中c++调用C代码 ,因为编译规则不一样,c++函数编译规则会使用name mingling ,C语言函数不会重载,找寻函数规则不一样


* 使用方法
![](/images/c++/重复定义.png)

```
.cpp文件会默认定一个宏,C不会默认定义

声明写在头文件中,实现写在.c里面,再根据是否有宏来区分c和c++环境

#include math.h;

# 防止重复加载-宏名字定义规范和文件名保持一致

#ifndef __MATH_H
    
    #define __MATH_H

    #ifdef _cplusplus
        extren "C" {
    #endif
            int sum();
            int del();
            int div();
    #ifdef _cplusplus
        } 
    #endif

#endif

---------------------------

#pragma once 也可以防止整个头文件重复加载,但是范围是整个文件,#ifndef可以定义某一部分
```
# 宏

* 纯粹的文本替换
```
#define add(v) v+v

int main(){
    int a = 10
    int c = add(++a);
    //替换为    
    int c = ++a + ++a  == 24
}
```
# 内联函数

* 使用inline修饰函数的声明或实现,可使其变成内联函数
* 建议声明和实现都加上inline,只要声明和实现任意加一个都是内联函数
* 特点
* *  编译器会降函数调用直接展开为函数体代码
* *  [函数调用是需要开辟函数栈空间的,结束回收栈空间,内存开销] -- 内联函数不需要开销,执行效率会提高
* *  会增大代码体积
* 什么时候使用内联函数?
* * 函数体积不是很大
* * 频繁调用的函数
* 注意
* * 尽量不要内联超过10行代码的函数
* * inline只是建议编译器可以内联,但是是否内联要看编译器心情[递归不会被内联,递归前面的一小段代码可能会被加载,但也只加载一次]
* * 编译器 release模式 ,关闭优化,开启内联开关
* 内联函数和宏
* * 宏也是替换,对比宏,内联函数多了函数检测和代码提示,简单的计算内联会比较好
 
```
# 编译器会降函数调用直接展开为函数体代码
inline void func(){
    cout << "function1" << endl;   
    cout << "function2" << endl;   
    cout << "function3" << endl;   
}
int main(){
    func();
    ----- func()变成 -----------
    cout << "function1" << endl;   
    cout << "function2" << endl;   
    cout << "function3" << endl;
    ---------------------------
}
```
# 表达式
```
int a = 1;
int b = 2;
(a = b ) = 4
(a>b?a:b) = 4

count << "a = " << a << endl;
count << "a = " << b << endl;
```
# const 
* 被修饰的表示为常量,不能修改,类似于java的final
* 修饰的是类,结构体(的指针),其他成员也不可以更改
```
struct Date{
    int year;
    int month;
    int day;
}
int main(){
    const Date d = {2011,2,5};
    Date d1 = {2011,2,5};
    d1.year = 2012;
    d1 = d;
    
    Date *p = &d1;
    p->year = 2022
    (*p).year = 2021
}
```
* const 修饰的是右边的内容
```
int main(){
    int age = 10;
    const int *p1 = $age;
    int const *p2 = $age;
    int * const p3 = $age;
    const int * const p4 = $age;
    *p5和p5是常量
    int const * const p5 = $age;
}
```

# 引用(reference)

* 在C可以用指针间接获取,修改某个变量的值
* 在C++ 引入引用&,可以接获取,修改某个变量的值
```
int age = 20;
//rage就是一个引用
int &rage = age;
```
* 注意点
* * 引用相当于是变量的别名(基本数据类型,枚举,结构体,类,指针,数组等,都可以有引用)
```
# 指针数组,存放3个int *
    int *p;
    int *arr[3] = {p,p,p};
# 用于指向数组的指针 - int[3] 的指针
    int (*arr2)[3]
# 用于指向数组的引用 - int[3] 的引用
    int arr[] = {1,2,3}
    int (&ref)[3] = arr;
    #另外一种写法
    int * const &ref = arr;
```
* * 对引用做计算,就是对引用所指向的变量做计算
* * 在定义的时候就必须初始化,一旦指向了某个变量,就不可以在改变,从一而终
* * 可以用引用初始化另一个引用,相当于某个变量的多个别名
```
#可以用引用初始化另一个引用,相当于某个变量的多个别名
    int height = 10;
    int &ref1 = height;
    int &ref2 = ref1;
    int &ref3 = ref2;
    ref1,ref2,ref3都指向height
```
* * 不存在[引用的引用,指向引用的指针,引用数组]
```
# 引用的引用
    int age = 10;
    int &ref = age;
    int &&ref2 = ref;
# 指向引用的指针
    int &*ref2 = &ref;
# 引用数组
    int &arr[4];
    int &arr[4] = {ref,ref,ref,ref} 其实就是4个age ,就是4个int,所以&符号无效,没有意义
    
```
* 价值
* * 比指针更安全,函数返回值可以被赋值 
* 引用的本质
* * 引用就是指针,只是被削弱了功能,所以引用就是弱化了的指针
```
int age = 10;

# *p就是age别名
    int *p = &age;
    *p = 30;

# ref就是age的别名
    int &ref = age;
    ref = 40;

# int 一个指针引用占用4个字节
# 一个指针变量*p 32位占用4个字节 64位是8个字节
# 一个引用占用一个指针的大小....引用就是弱化的指针
    struct{
        int &age;
        int *name;
        int sex;
    }
    cout << sizeof(Student) << endl;
```
* 常引用
* * 可以用于访问引用,不能修改地址值-只读 
![](/images/c++/汇编6.png)
```
# 引用和指针
    int age = 10;
    const int &ref = age;
    //ref = 30;
    const int *p = &age;
    //*p = 30;
# 常引用可以指向临时数据
    const int &ref = 30;
# 可以指向表达式
    int a = 1;
    int b =2;
    const int &ref = a+b;
# 可以指向函数返回值
    int fun(){
     return 8;
    }
    const int &ref = fun();
# 可以指向不同类型的数据
    int a = 10;
    const double &ref = a;
# 作为函数参数时(此规则也适用于const指针)
    可以接受const和非const实参(非const引用,只能接受非const实参)
    可以跟非const引用构成重载
    int sum(const int &v1,const int &v2){
        return v1+v2;
    }
    //重载
    int sum(int &v1,int &v2){
        return v1+v2;
    }
    int a =10;
    int b =20;
    sum(a,b);
    sum(10,20)//报错
    可以用const做一下兼容
    const int c = 10;
    const int d = 10;
    sum(c,d);
 # 当常引用指向了不同类型的数据,会生成临时变量,不是引用原来的对象了
     int c = 10;
     const long a  = c
     c =20;
     -- c=20 a还是10,生成一个临时变量,a 指向之前的地址  
```
# 汇编语言

## 基本概念
* 汇编语言的种类
* * 8066汇编(16bit)
* * x86汇编(32bit)
* * x64汇编(64bit)
* * Arm汇编(嵌入式,移动设备)
* x64汇编根据编译器不同,有两种书写格式
* * Intel
* * AT&T
* 汇编语言不区分大小写
* Intel & AT&T 区别
![](/images/c++/汇编1.png)

## 寄存器
 ### 程序的本质
 ![](/images/c++/汇编2.png)
 ### 寄存器与内存
 ![](/images/c++/汇编3.png)
 ### X64汇编-寄存器
 ![](/images/c++/汇编4.png)
 ![](/images/c++/汇编5.png)
 * 一个寄存器存8个字节的数据
 * RAX\RBX\RCX\RDX: 64位比较常见的通用寄存器
 * EAX\EBX\ECX\EDX: 32位比较常见的通用寄存器
 * AX\BX\CX\DX: 16位比较常见的通用寄存器
 * AH: A-HIGH AL: A-LOW 占1个字节
 
## X64汇编要点
![](/images/c++/mov.png)
```
# 一个字节占8位
# 1122h - h表示16进制
# 将右边src的值赋值给左边,类似于dest = src // mov dest,src
# [地址值] 中都是内存地址值
# word 是2字节,dword是4字节(double word),qword是8字节(quad word)
    mov dword ptr [1128h] 3 - 将3赋值到1128h地址往后4个字节
    mov eax, dword ptr[1128h] - 将1128h地址往后4个字节的数据赋值到寄存器
    4个字节存储3
        16进制 00 00 00 03H
        2进制  00000000 00000000 00000000 00000011(cpu大小端模式: 大部分是小端模式,值在低位,所以某个变量的地址值,是它所有字节地址的最小值)
    函数调用局部变量,所以需要[ebp-0Ch],地址相减,因为函数会动态分配地址
    全局变量地址是不会变的,mov时是固定的
# call 调用函数
# lea dest [地址值]
    lead effect address 装载一个有效的地址值 , 直接将地址值复值给dest 
# ret 函数返回
# xor op1,op2 将op1和op2异或的结果赋值给op1,类似于op1=op1^op2
# add op1,op2 将op1和op2相加的结果赋值给op1,类似于op1=op1+op2
# sub op1,op2 将op1和op2相减的结果赋值给op1,类似于op1=op1-op2
# inc op 自增,类似于op=op+1
# dec op 自增,类似于op=op-1
# jmp 内存地址 跳转到该地址执行命令
    j开头(jne,jle...)的一般都是跳转,大多数是带条件的跳转,一般是跟test,cmp等指令配合使用
# 为什么mov 不能 内存到内存,要通过寄存器?
    int a = 1;
    int b = a;
    不能直接 mov [b],[a],必须要通过eax
    imm 立即数 如1,m 内存
```

# 面向对象
* struct 定义的类成员都是public,class定义的类默认都是private,其他无区别
* 类的大小和类成员变量大小相关,int 4字节 指针8字节,类中的方法在内存中只有一份

## this
![](/images/c++/对象存储.png)
* this 指针存储着函数调用的地址
* this 指向了函数的调用者
* this 是指针,只能用->访问对象
* cc->int3(interrupt 中断):起到断点的作用
 
## 内存空间的布局
![](/images/c++/空间.png)
* 栈空间/堆空间/代码区/全局区
* 堆空间: 为了自由控制内存的生命周期,大小,会经常使用堆空间内存
```
# 堆空间申请和释放 malloc\free
  int *p = (int *)malloc(4);
  *p = 10;
  free(p); 
  
  char *p = (char *)malloc(4);
  *p = 10;
  *(p+1) = 11;
  等价于
  p[0] = 10;
  p[1] = 11;
  
  new (向堆空间申请内存)
  delete (释放)
  
  int *p = new int;
  delete p;
  
  []申请的需要配合使用
  new[]
  delete[]
# 初始化 - memory set(快速内存清零)
    int *p malloc(sizeof(int)*10)
    memset(p,1,sizeof(int)*10)# 从p地址开始,初始化40个字节,每一个字节(8位)全部都是1
    
    int *p0 = new int; # 没有初始化
    int *p1 = new int(); # 初始化为0
    int *p2 = new int(5); # 初始化为5
# 布局

struct Person{
    int m_age;
}

int main(){
    Person person; # 栈空间
    int *p = new Person(); # *p 在栈 / Person person在堆空间
}
```
## 构造函数
* malloc分配的对象不会调用构造函数
* 自定义了构造函数,实例就必须要通过自定义构造函数
![](/images/c++/构造.png)
![](/images/c++/构造1.png)
![](/images/c++/构造2.png)
```
Person person(); 这是函数声明
# 无构造函数
    # 栈空间: 没有初始化成员变量
    # 全局区: 会初始化 0
    # Person *p0 = new Person # 没有初始化
    # Person *p0 = new Person() # 初始化0
# 自定义构造函数
    # 全局区: 会初始化0,其他均不会初始化,堆空间需要开发人员自己去初始化,栈空间更不会初始化了
# 初始化对象-构造函数
Person(){
    memset(this,0,sizeof(Person))
}    
```
## 析构函数
![](/images/c++/析构.png)
![](/images/c++/析构2.png)
![](/images/c++/析构3.png)
```
# 对象内部生成的堆空间由对象自己delete回收

# 一个Person对象销毁的象征
~People(){
    cout<<"回收"<<endl;
}
# 用来做一些内存清理-清理内部生成的堆空间
## 对象包含了另一个对象的指针,并初始化了,需要做一些清理工作
~People(){
   delete people.m_car;
}
```
## 声明和实现分离
![](/images/c++/分离.png)
## 命名空间
![](/images/c++/命名空间.png)
![](/images/c++/命名空间1.png)
![](/images/c++/命名空间2.png)
## 继承
![](/images/c++/继承1.png)
![](/images/c++/继承2.png)
## 初始化列表
![](/images/c++/初始化.png)
```
# 只对构造函数有效,且定义的顺序与类的成员变量顺序有关
Person(int age,int height):m_age(age),m_height(height){}
等价于
Person(int age,int height){
    m_age = age;
    m_height = height;
}
```
## 构造函数互相调用
* 构造函数调用构造函数必须放在初始化列表里面
* this 指向的都是同一个对象
![](/images/c++/构造函数调用.png)
## 父类的构造函数
![](/images/c++/函数2.png)
```
# 子类的构造函数之前会调用父类的无参的无参构造函数[先有父亲再有孩子]
# 如果子类构造函数显式调用了父亲的构造函数就不会调用无参的构造函数了
# 如果父类没有无参构造函数,子类必须自己手动调用有参构造函数
# 父亲没有构造函数,就没有调用

# 析构函数
    * 析构函数是先子类释放,在调用父类
```
## 多态
* 通过虚函数virtual 实现,父类是虚函数,子类默认是虚函数
![](/images/c++/多态1.png)
![](/images/c++/多态2.png)
![](/images/c++/多态3.png) 
### 虚表
![](/images/c++/虚表.png)
![](/images/c++/虚表1.png)
![](/images/c++/虚表2.png)
```
# 增加virtual, 会在对象增加4个虚表的地址头,通过虚表去调用子类的函数
# 虚表里面放着是虚函数的地址
# 所有的cat对象都共用一个虚表
# 只要有virtual就会生成虚表
```
### 子类调用父类
```
# 直接把父类的名称拿过来用:Animal::speak();
```
## 虚析构函数
![](/images/c++/虚析构.png)
```
# 如果有父类指针指向子类对象,析构函数也应该是virtual虚函数类型
```
## 纯虚函数/抽象类
![](/images/c++/抽象类.png)
* 虚函数: 函数不需要实现,只定义函数名称[类似抽象类],virtual void speak() = 0;
* 含有纯虚函数的类是抽象类,不允许被new
## 多继承
![](/images/c++/多继承.png)
### 多继承的构造函数
* 使用访问列表去初始化构造函数
### 多继承的虚函数
* 会生成对应的多张虚表,两个父类会生成8个字节的虚函树地址
![](/images/c++/多继承虚表.png)
### 同名函数
![](/images/c++/同名函数.png)
### 同名成员变量
![](/images/c++/同名成员变量.png)
### 菱形继承
![](/images/c++/菱形继承.png)
### 虚继承-解决菱形继承问题
* 解决基类中成员变量重复的问题
* 会生成虚地址的指针,占用4字节
![](/images/c++/虚继承.png)
![](/images/c++/虚继承1.png)
![](/images/c++/虚继承2.png)
### 应用价值
![](/images/c++/多继承价值.png)
## 静态成员(static)
* ds 是数据段 data segment (全局区)
![](/images/c++/静态成员.png)
![](/images/c++/静态成员1.png)
## const成员
![](/images/c++/const成员.png)
## 引用类型成员
![](/images/c++/引用类型成员.png)
## 拷贝构造函数
* 需要深拷贝的时候需要实现一下拷贝构造函数
![](/images/c++/拷贝构造函数.png)
![](/images/c++/调用父类的拷贝.png)
```
# 拷贝构造函数
Car(const Car &car){}
#使用
Car car3;
Car car4(car3);
```
## 深拷贝与浅拷贝
![](/images/c++/深拷贝.png)
* 1.指向统一空间,修改数值都修改
* 2.释放还会造成dubble free 
![](/images/c++/深拷贝2.png)
![](/images/c++/深拷贝3.png)
![](/images/c++/深拷贝4.png)

## 对象作为返回值或者入参 会造成不必要的临时对象,进行拷贝
```
1.test(Car car){}

2.Car th(){
    Car car;
    return car;
}
```
## 匿名对象(临时对象) Car();
* 匿名对象作为返回值或者入参,编译器会优化不再进行拷贝构造
![](/images/c++/匿名对象.png)
## 隐式构造(转换构造)
* 可以通过explicit禁止隐式构造
![](/images/c++/隐式构造.png)
![](/images/c++/隐式构造2.png)
```
Person p1 = 20;
等价于
Person p2(20)
```
## 编译器生成构造函数 - 有事干就会生成
![](/images/c++/编译器.png)
## 友元
* get方法很频繁,想直接访问底油成员变量,使用友元函数 friend
* 友元函数和友元类
![](/images/c++/友元.png)
## 内部类
* 类A定义在类C里面,类A就是内部类,也叫嵌套类
* 可以设置权限,public,private,protected
![](/images/c++/内部类.png)
## 局部类
* 在一个函数内部定义的类
* 使用范围就是在函数内部
![](/images/c++/局部类.png)
# 运算符重载
* operator+/operator- ..等等
* 左边的const是保证Point不被修改,const函数是保证p1+p2+p3可通过
* ++a 是先对a进行++ 再返回a  a++ 是将a赋值 ,最后再进行++
* cout构造函数私有,外面就不能去赋值
* 单利模式需要私有化运算符重载 ,拷贝构造
* 仿函数 Sum sum; sum(1,2);
```
int a = 10;
int b = ++a +5;
-- int b = a+1+5;
int b = a++ + 5;
-- int b = 10 +5; a+=1;
```
![](/images/c++/运算符重载.png)
![](/images/c++/运算符重载1.png)
![](/images/c++/运算符重载2.png)
![](/images/c++/运算符重载3.png)
![](/images/c++/运算符重载4.png)
![](/images/c++/运算符重载5.png)
![](/images/c++/运算符重载6.png)
![](/images/c++/运算符重载7.png)
![](/images/c++/运算符重载8.png)
![](/images/c++/运算符重载9,.png)
# 模板(template)-泛型
![](/images/c++/模板1.png)
* 本质: 是编译器生成多个不同类型的同名函数
```
template <typename T> T add(T a, T b){
    return a+b;
}
template <typename T,typename A> T add(T a, A b){
    return a+b;
}
```
# 类型转换
```
#隐式转换
double a = 10;
#强制转换
1.const_cast - 将const转成非const  
    const_cast<Person *>(p1); 
    和(Person *) Person p1无区别
2.dynamic_cast - 多态集成转换函数
    和(..)转换区别: 运行过程中会进行安全过滤,不安全的赋值会被清空
3.static_cast
    和dynamic_cast相比,没有运行时安全检查
    不支持交叉转换,不同类之间的转换
    常用于基本数据类型转换,非const转成const
4.reinterpret_cast
    - int a = 10;
      double d = reinterpret_cast<double&>(a)
    - 直接将右边的二进制数据拷贝到左边
    - int *p = reinterpret_cast<int *>(0x100);
```
# C++11新特性
```
auto 自动判断类型
decltype 判断类型
nullptr  空指针
```
![](/images/c++/新特性.png)
# lambda 表达式
![](/images/c++/lambda.png)
![](/images/c++/lambda1.png)
![](/images/c++/变量捕获.png)
![](/images/c++/捕获.png)
```
[]{}就是lambda的标志
# 示例1
auto p = [](int a,int b) -> int {
    return a+b;
}

# mutable - 值捕获也可以修改a的值,但是只在表达式里面有效
auto func = [a]() mutable{
    a++;
    cout << a << endl; # 11
}
func();
cout << a<< endl; # 10
```
# 异常
```
# 所有异常
try{}catch(...){}
# C++ 没有finally
```
# 智能指针
![](/images/c++/智能指针1.png)
![](/images/c++/shared_ptr.png)
![](/images/c++/弱引用.png)
![](/images/c++/唯一ptr.png)
```
# 传统指针
    int *p = new int();
    delete p;
    *p = nullptr
    容易忘记释放内存    
# 智能指针
    auto_ptr(有缺陷,不能用于数组,因为析构函数 是delete不是delete[])
        auto_ptr<Person> p(new Person());
        可以理解:智能指针p指向了堆空间的Person对象
        重载了->的对象
    shared_ptr
        多个智能指针指向同一个对象
        引用计数,当count为0 就全部销毁
        有可能会出现double free 和循环引用,使用弱引用去解决weak_ptr
    unique_ptr
        不能同时指向一个对象,需要转移可以std::move      
```
# MFC
* 破解软件 OllyDBG软件
## 打印
```
void CPVZCheaterDlg::OnBtnClickCourse() {
	//TRACE("AGE IS %d\n", 20);
	int a = 20;
	CString str;
	str.Format(CString("AGE IS %d"), a);
	//AfxMessageBox(str);
	MessageBox(str, CString("AGE IS"),MB_YESNOCANCEL|MB_HELP);
}
#利用宏定义格式
#define log(fmt,...)\
CString str;\
str.Format(CString(fmt), __VA_ARGS__);\
AfxMessageBox(str);
```
## 访问网址
```
//全局函数
::ShellExecute(NULL, CString("open"), CString("http://www.baidu.com"), NULL, NULL, SW_NORMAL);
```
## 判断box-checked
```
//判断方法
//bool checked = IsDlgButtonChecked(IDC_KILL);
//通过指针变量
//CButton *button = (CButton*)GetDlgItem(IDC_KILL);
//bool checked = button->GetCheck;
//绑定成员变量
//  DoDataExchange - 绑定成员变量  BEGIN_MESSAGE_MAP - 绑定点击事件
//	DDX_Control(pDX, IDC_KILL, m_bnKill);
//判断
bool checked = m_bnKill.GetCheck;
if (checked) {
    log("checked");
}else {
    log("no");
}
```